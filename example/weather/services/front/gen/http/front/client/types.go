// Code generated by goa v3.14.2, DO NOT EDIT.
//
// front HTTP client types
//
// Command:
// $ goa gen goa.design/clue/example/weather/services/front/design -o
// services/front

package client

import (
	front "goa.design/clue/example/weather/services/front/gen/front"
	goa "goa.design/goa/v3/pkg"
)

// TestAllRequestBody is the type of the "front" service "test_all" endpoint
// HTTP request body.
type TestAllRequestBody struct {
	// Tests to run
	Include []string `form:"include,omitempty" json:"include,omitempty" xml:"include,omitempty"`
	// Tests to exclude
	Exclude []string `form:"exclude,omitempty" json:"exclude,omitempty" xml:"exclude,omitempty"`
}

// ForecastResponseBody is the type of the "front" service "forecast" endpoint
// HTTP response body.
type ForecastResponseBody struct {
	// Forecast location
	Location *LocationResponseBody `form:"location,omitempty" json:"location,omitempty" xml:"location,omitempty"`
	// Weather forecast periods
	Periods []*PeriodResponseBody `form:"periods,omitempty" json:"periods,omitempty" xml:"periods,omitempty"`
}

// TestAllResponseBody is the type of the "front" service "test_all" endpoint
// HTTP response body.
type TestAllResponseBody struct {
	// Test collections
	Collections []*TestCollectionResponseBody `form:"collections,omitempty" json:"collections,omitempty" xml:"collections,omitempty"`
	// Duration of the tests in ms
	Duration *int64 `form:"duration,omitempty" json:"duration,omitempty" xml:"duration,omitempty"`
	// Number of tests that passed
	PassCount *int `form:"pass_count,omitempty" json:"pass_count,omitempty" xml:"pass_count,omitempty"`
	// Number of tests that failed
	FailCount *int `form:"fail_count,omitempty" json:"fail_count,omitempty" xml:"fail_count,omitempty"`
}

// TestSmokeResponseBody is the type of the "front" service "test_smoke"
// endpoint HTTP response body.
type TestSmokeResponseBody struct {
	// Test collections
	Collections []*TestCollectionResponseBody `form:"collections,omitempty" json:"collections,omitempty" xml:"collections,omitempty"`
	// Duration of the tests in ms
	Duration *int64 `form:"duration,omitempty" json:"duration,omitempty" xml:"duration,omitempty"`
	// Number of tests that passed
	PassCount *int `form:"pass_count,omitempty" json:"pass_count,omitempty" xml:"pass_count,omitempty"`
	// Number of tests that failed
	FailCount *int `form:"fail_count,omitempty" json:"fail_count,omitempty" xml:"fail_count,omitempty"`
}

// ForecastNotUsaResponseBody is the type of the "front" service "forecast"
// endpoint HTTP response body for the "not_usa" error.
type ForecastNotUsaResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// LocationResponseBody is used to define fields on response body types.
type LocationResponseBody struct {
	// Latitude
	Lat *float64 `form:"lat,omitempty" json:"lat,omitempty" xml:"lat,omitempty"`
	// Longitude
	Long *float64 `form:"long,omitempty" json:"long,omitempty" xml:"long,omitempty"`
	// City
	City *string `form:"city,omitempty" json:"city,omitempty" xml:"city,omitempty"`
	// State
	State *string `form:"state,omitempty" json:"state,omitempty" xml:"state,omitempty"`
}

// PeriodResponseBody is used to define fields on response body types.
type PeriodResponseBody struct {
	// Period name
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Start time
	StartTime *string `form:"startTime,omitempty" json:"startTime,omitempty" xml:"startTime,omitempty"`
	// End time
	EndTime *string `form:"endTime,omitempty" json:"endTime,omitempty" xml:"endTime,omitempty"`
	// Temperature
	Temperature *int `form:"temperature,omitempty" json:"temperature,omitempty" xml:"temperature,omitempty"`
	// Temperature unit
	TemperatureUnit *string `form:"temperatureUnit,omitempty" json:"temperatureUnit,omitempty" xml:"temperatureUnit,omitempty"`
	// Summary
	Summary *string `form:"summary,omitempty" json:"summary,omitempty" xml:"summary,omitempty"`
}

// TestCollectionResponseBody is used to define fields on response body types.
type TestCollectionResponseBody struct {
	// Name of the test collection
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Test results
	Results []*TestResultResponseBody `form:"results,omitempty" json:"results,omitempty" xml:"results,omitempty"`
	// Duration of the tests in ms
	Duration *int64 `form:"duration,omitempty" json:"duration,omitempty" xml:"duration,omitempty"`
	// Number of tests that passed
	PassCount *int `form:"pass_count,omitempty" json:"pass_count,omitempty" xml:"pass_count,omitempty"`
	// Number of tests that failed
	FailCount *int `form:"fail_count,omitempty" json:"fail_count,omitempty" xml:"fail_count,omitempty"`
}

// TestResultResponseBody is used to define fields on response body types.
type TestResultResponseBody struct {
	// Name of the test
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Status of the test
	Passed *bool `form:"passed,omitempty" json:"passed,omitempty" xml:"passed,omitempty"`
	// Error message if the test failed
	Error *string `form:"error,omitempty" json:"error,omitempty" xml:"error,omitempty"`
	// Duration of the test in ms
	Duration *int64 `form:"duration,omitempty" json:"duration,omitempty" xml:"duration,omitempty"`
}

// NewTestAllRequestBody builds the HTTP request body from the payload of the
// "test_all" endpoint of the "front" service.
func NewTestAllRequestBody(p *front.TestAllPayload) *TestAllRequestBody {
	body := &TestAllRequestBody{}
	if p.Include != nil {
		body.Include = make([]string, len(p.Include))
		for i, val := range p.Include {
			body.Include[i] = val
		}
	}
	if p.Exclude != nil {
		body.Exclude = make([]string, len(p.Exclude))
		for i, val := range p.Exclude {
			body.Exclude[i] = val
		}
	}
	return body
}

// NewForecast2OK builds a "front" service "forecast" endpoint result from a
// HTTP "OK" response.
func NewForecast2OK(body *ForecastResponseBody) *front.Forecast2 {
	v := &front.Forecast2{}
	v.Location = unmarshalLocationResponseBodyToFrontLocation(body.Location)
	v.Periods = make([]*front.Period, len(body.Periods))
	for i, val := range body.Periods {
		v.Periods[i] = unmarshalPeriodResponseBodyToFrontPeriod(val)
	}

	return v
}

// NewForecastNotUsa builds a front service forecast endpoint not_usa error.
func NewForecastNotUsa(body *ForecastNotUsaResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewTestAllTestResultsOK builds a "front" service "test_all" endpoint result
// from a HTTP "OK" response.
func NewTestAllTestResultsOK(body *TestAllResponseBody) *front.TestResults {
	v := &front.TestResults{
		Duration:  *body.Duration,
		PassCount: *body.PassCount,
		FailCount: *body.FailCount,
	}
	v.Collections = make([]*front.TestCollection, len(body.Collections))
	for i, val := range body.Collections {
		v.Collections[i] = unmarshalTestCollectionResponseBodyToFrontTestCollection(val)
	}

	return v
}

// NewTestSmokeTestResultsOK builds a "front" service "test_smoke" endpoint
// result from a HTTP "OK" response.
func NewTestSmokeTestResultsOK(body *TestSmokeResponseBody) *front.TestResults {
	v := &front.TestResults{
		Duration:  *body.Duration,
		PassCount: *body.PassCount,
		FailCount: *body.FailCount,
	}
	v.Collections = make([]*front.TestCollection, len(body.Collections))
	for i, val := range body.Collections {
		v.Collections[i] = unmarshalTestCollectionResponseBodyToFrontTestCollection(val)
	}

	return v
}

// ValidateForecastResponseBody runs the validations defined on
// ForecastResponseBody
func ValidateForecastResponseBody(body *ForecastResponseBody) (err error) {
	if body.Location == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("location", "body"))
	}
	if body.Periods == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("periods", "body"))
	}
	if body.Location != nil {
		if err2 := ValidateLocationResponseBody(body.Location); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	for _, e := range body.Periods {
		if e != nil {
			if err2 := ValidatePeriodResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateTestAllResponseBody runs the validations defined on
// test_all_response_body
func ValidateTestAllResponseBody(body *TestAllResponseBody) (err error) {
	if body.Collections == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("collections", "body"))
	}
	if body.Duration == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("duration", "body"))
	}
	if body.PassCount == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("pass_count", "body"))
	}
	if body.FailCount == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fail_count", "body"))
	}
	for _, e := range body.Collections {
		if e != nil {
			if err2 := ValidateTestCollectionResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateTestSmokeResponseBody runs the validations defined on
// test_smoke_response_body
func ValidateTestSmokeResponseBody(body *TestSmokeResponseBody) (err error) {
	if body.Collections == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("collections", "body"))
	}
	if body.Duration == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("duration", "body"))
	}
	if body.PassCount == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("pass_count", "body"))
	}
	if body.FailCount == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fail_count", "body"))
	}
	for _, e := range body.Collections {
		if e != nil {
			if err2 := ValidateTestCollectionResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateForecastNotUsaResponseBody runs the validations defined on
// forecast_not_usa_response_body
func ValidateForecastNotUsaResponseBody(body *ForecastNotUsaResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateLocationResponseBody runs the validations defined on
// LocationResponseBody
func ValidateLocationResponseBody(body *LocationResponseBody) (err error) {
	if body.Lat == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("lat", "body"))
	}
	if body.Long == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("long", "body"))
	}
	if body.City == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("city", "body"))
	}
	if body.State == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("state", "body"))
	}
	return
}

// ValidatePeriodResponseBody runs the validations defined on PeriodResponseBody
func ValidatePeriodResponseBody(body *PeriodResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.StartTime == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("startTime", "body"))
	}
	if body.EndTime == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("endTime", "body"))
	}
	if body.Temperature == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temperature", "body"))
	}
	if body.TemperatureUnit == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temperatureUnit", "body"))
	}
	if body.Summary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("summary", "body"))
	}
	if body.StartTime != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.startTime", *body.StartTime, goa.FormatDateTime))
	}
	if body.EndTime != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.endTime", *body.EndTime, goa.FormatDateTime))
	}
	return
}

// ValidateTestCollectionResponseBody runs the validations defined on
// TestCollectionResponseBody
func ValidateTestCollectionResponseBody(body *TestCollectionResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.Duration == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("duration", "body"))
	}
	if body.PassCount == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("pass_count", "body"))
	}
	if body.FailCount == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fail_count", "body"))
	}
	for _, e := range body.Results {
		if e != nil {
			if err2 := ValidateTestResultResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateTestResultResponseBody runs the validations defined on
// TestResultResponseBody
func ValidateTestResultResponseBody(body *TestResultResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.Passed == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("passed", "body"))
	}
	if body.Duration == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("duration", "body"))
	}
	return
}
